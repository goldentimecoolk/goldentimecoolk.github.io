<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="写在前面：经过几天的琢磨，caffe的使用流程已经基本掌握，但我始终对一些问题感到好奇，比如写的那些文本是如何形成网络的，在命令行输入的参数是怎么调用相应程序的，网路中每个层（module）的那些参数（或说属性）是怎么定义的？等等。这种好奇让我觉得很没谱，万一某一天caffe没有按照想法进行工作，或者在caffe主体的基础上自己有了一点不一样的想法，我该怎么去改？虽然这种情况出现时，我的水平可能已">
<meta property="og:type" content="article">
<meta property="og:title" content="【caffe】从命令行到函数调用">
<meta property="og:url" content="http://yoursite.com/2018/06/10/【caffe】从命令行到函数调用/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="写在前面：经过几天的琢磨，caffe的使用流程已经基本掌握，但我始终对一些问题感到好奇，比如写的那些文本是如何形成网络的，在命令行输入的参数是怎么调用相应程序的，网路中每个层（module）的那些参数（或说属性）是怎么定义的？等等。这种好奇让我觉得很没谱，万一某一天caffe没有按照想法进行工作，或者在caffe主体的基础上自己有了一点不一样的想法，我该怎么去改？虽然这种情况出现时，我的水平可能已">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2018-08-06T09:26:21.506Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="【caffe】从命令行到函数调用">
<meta name="twitter:description" content="写在前面：经过几天的琢磨，caffe的使用流程已经基本掌握，但我始终对一些问题感到好奇，比如写的那些文本是如何形成网络的，在命令行输入的参数是怎么调用相应程序的，网路中每个层（module）的那些参数（或说属性）是怎么定义的？等等。这种好奇让我觉得很没谱，万一某一天caffe没有按照想法进行工作，或者在caffe主体的基础上自己有了一点不一样的想法，我该怎么去改？虽然这种情况出现时，我的水平可能已">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: false,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/06/10/【caffe】从命令行到函数调用/"/>





  <title>【caffe】从命令行到函数调用 | Hexo</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-123344658-1', 'auto');
  ga('send', 'pageview');
</script>





</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/10/【caffe】从命令行到函数调用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Sky">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">【caffe】从命令行到函数调用</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-06-10T00:00:00+08:00">
                2018-06-10
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2018-08-06T17:26:21+08:00">
                2018-08-06
              </time>
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/06/10/【caffe】从命令行到函数调用/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count gitment-comments-count" data-xid="/2018/06/10/【caffe】从命令行到函数调用/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv">本文总阅读量
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>次
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>写在前面：<br>经过几天的琢磨，caffe的使用流程已经基本掌握，但我始终对一些问题感到好奇，比如写的那些文本是如何形成网络的，在命令行输入的参数是怎么调用相应程序的，网路中每个层（module）的那些参数（或说属性）是怎么定义的？等等。这种好奇让我觉得很没谱，万一某一天caffe没有按照想法进行工作，或者在caffe主体的基础上自己有了一点不一样的想法，我该怎么去改？虽然这种情况出现时，我的水平可能已经很高了，但是现在始终在心里挥之不去。因此抽时间查找了一些相关材料，汇总如下。</p>
<p>在caffe.cpp的开头，可以看到很多宏，例如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DEFINE_string(gpu, <span class="string">""</span>,</span><br><span class="line">    <span class="string">"Optional; run in GPU mode on given device IDs separated by ','."</span></span><br><span class="line">    <span class="string">"Use '-gpu all' to run on all available GPUs. The effective training "</span></span><br><span class="line">    <span class="string">"batch size is multiplied by the number of devices."</span>);</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>这个宏的使用方式为DEFINE_xxx(name, default_value, instruction);，这样就定义了一个xxx类型名为FLAGS_name的标志，如果用户没有在Command Line中提供其值，那么会默认为default_value，instruction是这个标志含义的说明。因此，上面的代码定义了一个string类型的名为FLAGS_gpu的标志，如果在Command Line中用户没有提供值，那么会默认为空字符串，根据说明可以得知这个标志是提供给用户来指定caffe将使用的GPU的。</p>
</blockquote>
<p>定义了很多标志，要有相应的代码对其进行解析。</p>
<blockquote>
<p>解析这些标志的代码在caffe.cpp中的main()中调用了/CAFFE_ROOT/src/common.cpp中的GlobalInit(&amp;argc, &amp;argv)函数。</p>
</blockquote>
<p>###从命令行写入参数，到具体的调用函数</p>
<p>在调用caffe网络时，我们在命令行写入如下参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">caffe train -solver=solver.prototxt -weights=pretrained-weights.caffemodel -gpu 0</span><br></pre></td></tr></table></figure></p>
<p><strong>第一个参数</strong>是train/test/time/device_query，表示要实现的功能。对该部分参数解析的实质是GetBrewFunction函数得到四个函数的指针。当然，这四个指针首先要通过RegisterBrewFunction这个宏完成函数的注册。两个函数的定义如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RegisterBrewFunction(func) \</span></span><br><span class="line"><span class="keyword">namespace</span> &#123; \</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">Registerer_</span>##<span class="title">func</span> &#123;</span> \</span><br><span class="line"> <span class="keyword">public</span>: <span class="comment">/* NOLINT */</span> \</span><br><span class="line">  __Registerer_#<span class="meta">#func() &#123; \</span></span><br><span class="line">    g_brew_map[<span class="meta">#func] = &amp;func; \</span></span><br><span class="line">  &#125; \</span><br><span class="line">&#125;; \</span><br><span class="line">__Registerer_#<span class="meta">#func g_registerer_##func; \</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> BrewFunction <span class="title">GetBrewFunction</span><span class="params">(<span class="keyword">const</span> caffe::<span class="built_in">string</span>&amp; name)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (g_brew_map.count(name)) &#123;</span><br><span class="line">    <span class="keyword">return</span> g_brew_map[name];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    LOG(ERROR) &lt;&lt; <span class="string">"Available caffe actions:"</span>;</span><br><span class="line">    <span class="keyword">for</span> (BrewMap::iterator it = g_brew_map.begin();</span><br><span class="line">         it != g_brew_map.end(); ++it) &#123;</span><br><span class="line">      LOG(ERROR) &lt;&lt; <span class="string">"\t"</span> &lt;&lt; it-&gt;first;</span><br><span class="line">    &#125;</span><br><span class="line">    LOG(FATAL) &lt;&lt; <span class="string">"Unknown action: "</span> &lt;&lt; name;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;  <span class="comment">// not reachable, just to suppress old compiler warnings.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>以train函数为例子，RegisterBrewFunction(train)这个宏的作用是定义了一个名为__Register_train的类，在定义完这个类之后，定义了一个这个类的变量，会调用构造函数，这个类的构造函数在前面提到的g_brew_map中添加了key为”train”，value为指向train函数的指针的一个元素。</p>
</blockquote>
<p>其中<code>g_brew_map</code>为一个全局变量：</p>
<pre><code>// A simple registry for caffe commands.
typedef int (*BrewFunction)();
typedef std::map&lt;caffe::string, BrewFunction&gt; BrewMap;
BrewMap g_brew_map;
</code></pre><p>main函数内容如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Print output to stderr (while still logging).</span></span><br><span class="line">  FLAGS_alsologtostderr = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// Set version</span></span><br><span class="line">  gflags::SetVersionString(AS_STRING(CAFFE_VERSION));</span><br><span class="line">  <span class="comment">// Usage message.</span></span><br><span class="line">  gflags::SetUsageMessage(<span class="string">"command line brew\n"</span></span><br><span class="line">      <span class="string">"usage: caffe &lt;command&gt; &lt;args&gt;\n\n"</span></span><br><span class="line">      <span class="string">"commands:\n"</span></span><br><span class="line">      <span class="string">"  train           train or finetune a model\n"</span></span><br><span class="line">      <span class="string">"  test            score a model\n"</span></span><br><span class="line">      <span class="string">"  device_query    show GPU diagnostic information\n"</span></span><br><span class="line">      <span class="string">"  time            benchmark model execution time"</span>);</span><br><span class="line">  <span class="comment">// Run tool or show usage.</span></span><br><span class="line">  caffe::GlobalInit(&amp;argc, &amp;argv);</span><br><span class="line">  <span class="keyword">if</span> (argc == <span class="number">2</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> WITH_PYTHON_LAYER</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">      <span class="keyword">return</span> GetBrewFunction(caffe::<span class="built_in">string</span>(argv[<span class="number">1</span>]))();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> WITH_PYTHON_LAYER</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (bp::error_already_set) &#123;</span><br><span class="line">      PyErr_Print();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    gflags::ShowUsageWithFlagsRestrict(argv[<span class="number">0</span>], <span class="string">"tools/caffe"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>总结：RegisterBrewFunction这个宏在每一个实现主要功能的函数之后将这个函数的名字和其对应的函数指针添加到了g_brew_map中，然后在main函数中，通过GetBrewFunction得到了我们需要调用的那个函数的函数指针，并完成了调用。</p>
</blockquote>
<p><strong>这样就实现了四个函数train/test/time/device_query的调用。</strong></p>
<hr>
<p>下面以train的内部结构为例看看后续的运行流程。</p>
<p>开头：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CHECK_GT(FLAGS_solver.size(), <span class="number">0</span>) &lt;&lt; <span class="string">"Need a solver definition to train."</span>;</span><br><span class="line">CHECK(!FLAGS_snapshot.size() || !FLAGS_weights.size())</span><br><span class="line">    &lt;&lt; <span class="string">"Give a snapshot to resume training or weights to finetune "</span></span><br><span class="line">    <span class="string">"but not both."</span>;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>这段代码的第一行使用了glog的CHECK_GT宏（含义为check greater than），检查FLAGS_solver的size是否大于0，如果小于或等于0则输出提示：”Need a solver definition to train”。FLAGS_solver是最开始通过DEFINE_string定义的标志，如果我们希望训练一个模型，那么自然应该应该提供对应的solver定义文件的路径，这一句话正是在确保我们提供了这样的路径。这样的检查语句在后续的代码中会经常出现，将不再一一详细解释，如果有不清楚含义的glog宏可以去看看文档。 与第一行代码类似，第二行代码是确保用户没有同时提供snapshot和weights参数，这两个参数都是继续之前的训练或者进行fine-tuning的，如果同时指明了这两个标志，则不知道到底应该从哪个路径的文件去读入模型的相关参数更为合适。</p>
</blockquote>
<p>接下来是：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; stages = get_stages_from_flags();</span><br></pre></td></tr></table></figure></p>
<p>该函数的定义：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Parse stages from flags</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; get_stages_from_flags() &#123;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; stages;</span><br><span class="line">  boost::split(stages, FLAGS_stage, boost::is_any_of(<span class="string">","</span>));</span><br><span class="line">  <span class="keyword">return</span> stages;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>需要注意stage和phase不一样，但是具体的区别暂时不清楚，以后遇到就会知道。下面是phase的定义：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Parse phase from flags</span></span><br><span class="line">caffe::<span class="function">Phase <span class="title">get_phase_from_flags</span><span class="params">(caffe::Phase default_value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (FLAGS_phase == <span class="string">""</span>)</span><br><span class="line">    <span class="keyword">return</span> default_value;</span><br><span class="line">  <span class="keyword">if</span> (FLAGS_phase == <span class="string">"TRAIN"</span>)</span><br><span class="line">    <span class="keyword">return</span> caffe::TRAIN;</span><br><span class="line">  <span class="keyword">if</span> (FLAGS_phase == <span class="string">"TEST"</span>)</span><br><span class="line">    <span class="keyword">return</span> caffe::TEST;</span><br><span class="line">  LOG(FATAL) &lt;&lt; <span class="string">"phase must be \"TRAIN\" or \"TEST\""</span>;</span><br><span class="line">  <span class="keyword">return</span> caffe::TRAIN;  <span class="comment">// Avoid warning</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来是：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  caffe::SolverParameter solver_param;</span><br><span class="line">  caffe::ReadSolverParamsFromTextFileOrDie(FLAGS_solver, &amp;solver_param);</span><br><span class="line"></span><br><span class="line">即从solver.prototxt中获取相关的配置参数。看一下这个函数：</span><br><span class="line"></span><br><span class="line"><span class="comment">// Read parameters from a file into a SolverParameter proto message.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReadSolverParamsFromTextFileOrDie</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; param_file,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       SolverParameter* param)</span> </span>&#123;</span><br><span class="line">  CHECK(ReadProtoFromTextFile(param_file, param))</span><br><span class="line">      &lt;&lt; <span class="string">"Failed to parse SolverParameter file: "</span> &lt;&lt; param_file;</span><br><span class="line">  UpgradeSolverAsNeeded(param_file, param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中又调用了另一个函数<code>ReadProtoFromTextFile(param_file, param)</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ReadProtoFromTextFile</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* filename, Message* proto)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> fd = open(filename, O_RDONLY);</span><br><span class="line">  CHECK_NE(fd, <span class="number">-1</span>) &lt;&lt; <span class="string">"File not found: "</span> &lt;&lt; filename;</span><br><span class="line">  FileInputStream* input = <span class="keyword">new</span> FileInputStream(fd);</span><br><span class="line">  <span class="keyword">bool</span> success = google::protobuf::TextFormat::Parse(input, proto);</span><br><span class="line">  <span class="keyword">delete</span> input;</span><br><span class="line">  close(fd);</span><br><span class="line">  <span class="keyword">return</span> success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一路跟踪参数<code>param_file</code>可以发现，<code>FLAGS_solver</code>是prototxt的文件路径，而<code>solver_param</code>存放从其中解析到的配置参数信息，即这一系列函数的作用是从<code>param_file</code>这个路径去读取solver的定义。</p>
<p>要想了解<strong>solver一共包含哪些参数</strong>，分别表示什么，能够修改哪些信息？可以通过<code>message SolverParameter{xxx}</code>一探究竟，路径是<code>./src/caffe/proto/caffe.proto</code>. 此外，其背后的工作原理是</p>
<blockquote>
<p>caffe通过Google Protocol Buffer来定义data schema。</p>
</blockquote>
<p>可以通过<a href="http://alanse7en.github.io/caffedai-ma-jie-xi-2/" target="_blank" rel="noopener">这篇博客</a>了解一下。</p>
<p>回到train函数，后面基本都是对参数的一些解析，如设置gpu模式、遇到系统信号时（用户按了ctrl+c或者关闭了当前的terminal）的处理方式等。具体的细节，此处先不深入探讨，以后如有需要，再做补充。这里主要提出两个函数进行分析：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">solver-&gt;SetActionFunction(signal_handler.GetActionFunction());</span><br></pre></td></tr></table></figure>
<p>和<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">solver-&gt;Solve();</span><br></pre></td></tr></table></figure></p>
<p>其中涉及到以下四个方面：</p>
<blockquote>
<ul>
<li>Solver的初始化（Register宏和构造函数）</li>
<li>SIGINT和SIGHUP信号的处理</li>
<li>Solver::Solve()具体实现</li>
<li>SGDSolver::ApplyUpdate具体实现</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;caffe::Solver&lt;<span class="keyword">float</span>&gt; &gt;</span><br><span class="line">    solver(caffe::SolverRegistry&lt;<span class="keyword">float</span>&gt;::CreateSolver(solver_param));</span><br></pre></td></tr></table></figure>
<p>该段代码定义一个指向Solver的shared_ptr。其中主要是通过调用SolverRegistry这个类的静态成员函数CreateSolver得到一个指向Solver的指针来构造shared_ptr类型的solver。</p>
<p>下面具体看一下SolverRegistry这个类的代码，以便理解“如何通过同一个函数得到不同类型的Solver”：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SolverRegistry</span> &#123;</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> Solver&lt;Dtype&gt;* (*Creator)(<span class="keyword">const</span> SolverParameter&amp;);</span><br><span class="line">  <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">string</span>, Creator&gt; CreatorRegistry;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> CreatorRegistry&amp; <span class="title">Registry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> CreatorRegistry* g_registry_ = <span class="keyword">new</span> CreatorRegistry();</span><br><span class="line">    <span class="keyword">return</span> *g_registry_;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AddCreator</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; type, Creator creator)</span> </span>&#123;</span><br><span class="line">    CreatorRegistry&amp; registry = Registry();</span><br><span class="line">    CHECK_EQ(registry.count(type), <span class="number">0</span>)</span><br><span class="line">        &lt;&lt; <span class="string">"Solver type "</span> &lt;&lt; type &lt;&lt; <span class="string">" already registered."</span>;</span><br><span class="line">    registry[type] = creator;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> Solver&lt;Dtype&gt;* CreateSolver(<span class="keyword">const</span> SolverParameter&amp; param) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">string</span>&amp; type = param.type();</span><br><span class="line">    CreatorRegistry&amp; registry = Registry();</span><br><span class="line">    CHECK_EQ(registry.count(type), <span class="number">1</span>) &lt;&lt; <span class="string">"Unknown solver type: "</span> &lt;&lt; type</span><br><span class="line">        &lt;&lt; <span class="string">" (known types: "</span> &lt;&lt; SolverTypeListString() &lt;&lt; <span class="string">")"</span>;</span><br><span class="line">    <span class="keyword">return</span> registry[type](param);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; SolverTypeList() &#123;</span><br><span class="line">    CreatorRegistry&amp; registry = Registry();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; solver_types;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">typename</span> CreatorRegistry::iterator iter = registry.begin();</span><br><span class="line">         iter != registry.end(); ++iter) &#123;</span><br><span class="line">      solver_types.push_back(iter-&gt;first);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> solver_types;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  SolverRegistry() &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="built_in">string</span> <span class="title">SolverTypeListString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; solver_types = SolverTypeList();</span><br><span class="line">    <span class="built_in">string</span> solver_types_str;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::iterator iter = solver_types.begin();</span><br><span class="line">         iter != solver_types.end(); ++iter) &#123;</span><br><span class="line">      <span class="keyword">if</span> (iter != solver_types.begin()) &#123;</span><br><span class="line">        solver_types_str += <span class="string">", "</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      solver_types_str += *iter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> solver_types_str;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>从<code>CreateSolver</code>函数(第15行)入手，这个函数先定义了string类型的变量type，表示Solver的类型(SGD/Nestrov等)，然后定义了一个key类型为string，value类型为Creator的map：<code>registry</code>(4、5、6、17行)，其中Creator是一个函数指针类型，指向的函数的参数为<code>SolverParameter</code>类型，返回类型为<code>Solver*</code>(见第2行和第3行)。如果是一个已经register过的Solver类型，那么registry.count(type)应该为1，然后通过registry这个map返回了我们需要类型的Solver的creator，并调用这个creator函数，将creator返回的Solver*返回。</p>
<p>上面的代码中，Registry这个函数（第5行）中定义了一个static的变量g_registry，这个变量是一个指向CreatorRegistry这个map类型的指针，然后直接返回，因为这个变量是static的，所以即使多次调用这个函数，也只会定义一个g_registry，而且在其他地方修改这个map里的内容，是存储在这个map中的。事实上各个Solver的register的过程正是往g_registry指向的那个map里添加以Solver的type为key，对应的Creator函数指针为value的内容。</p>
<p>函数<code>static void AddCreator(const string&amp; type, Creator creator)</code>在添加creator的时候调用。下面具体来看一下Solver的register的过程：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Dtype&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SolverRegisterer</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  SolverRegisterer(<span class="keyword">const</span> <span class="built_in">string</span>&amp; type,</span><br><span class="line">      Solver&lt;Dtype&gt;* (*creator)(<span class="keyword">const</span> SolverParameter&amp;)) &#123;</span><br><span class="line">    <span class="comment">// LOG(INFO) &lt;&lt; "Registering solver type: " &lt;&lt; type;</span></span><br><span class="line">    SolverRegistry&lt;Dtype&gt;::AddCreator(type, creator);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REGISTER_SOLVER_CREATOR(type, creator)                                 \</span></span><br><span class="line">  <span class="keyword">static</span> SolverRegisterer&lt;<span class="keyword">float</span>&gt; g_creator_f_#<span class="meta">#type(#type, creator<span class="meta-string">&lt;float&gt;);    \</span></span></span><br><span class="line">  <span class="keyword">static</span> SolverRegisterer&lt;<span class="keyword">double</span>&gt; g_creator_d_#<span class="meta">#type(#type, creator<span class="meta-string">&lt;double&gt;)   \</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REGISTER_SOLVER_CLASS(type)                                            \</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Dtype&gt;                                                    \</span><br><span class="line">  Solver&lt;Dtype&gt;* Creator_#<span class="meta">#type##Solver(                                       \</span></span><br><span class="line">      <span class="keyword">const</span> SolverParameter&amp; param)                                            \</span><br><span class="line">  &#123;                                                                            \</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> type##Solver&lt;Dtype&gt;(param);                                     \</span><br><span class="line">  &#125;                                                                            \</span><br><span class="line">  REGISTER_SOLVER_CREATOR(type, Creator_##type##Solver)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// register SGD Solver</span></span><br><span class="line">REGISTER_SOLVER_CLASS(SGD);</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>在sgd_solver.cpp(SGD Solver对应的cpp文件)末尾有上面第24行的代码，使用了REGISTER_SOLVER_CLASS这个宏，这个宏会定义一个名为Creator_SGDSolver的函数，这个函数即为Creator类型的指针指向的函数，在这个函数中调用了SGDSolver的构造函数，并将构造的这个变量得到的指针返回，这也就是Creator类型函数的作用：构造一个对应类型的Solver对象，将其指针返回。然后在这个宏里又调用了REGISTER_SOLVER_CREATOR这个宏，这里分别定义了SolverRegisterer这个模板类的float和double类型的static变量，这会去调用各自的构造函数，而在SolverRegisterer的构造函数中调用了之前提到的SolverRegistry类的AddCreator函数，这个函数就是将刚才定义的Creator_SGDSolver这个函数的指针存到g_registry指向的map里面。类似地，所有的Solver对应的cpp文件的末尾都调用了这个宏来完成注册，在所有的Solver都注册之后，我们就可以通过之前描述的方式，通过g_registry得到对应的Creator函数的指针，并通过调用这个Creator函数来构造对应的Solver。</p>
</blockquote>
<h3 id="SIGINT和SIGHUP信号的处理"><a href="#SIGINT和SIGHUP信号的处理" class="headerlink" title="SIGINT和SIGHUP信号的处理"></a>SIGINT和SIGHUP信号的处理</h3><p>Caffe在train或者test的过程中都有可能会遇到系统信号(用户按下ctrl+c或者关掉了控制的terminal)，我们可以通过对<code>sigint_effect</code>和<code>sighup_effect</code>来设置遇到系统信号的时候希望进行的处理方式：</p>
<pre><code>caffe train –solver=/path/to/solver.prototxt –sigint_effect=EFFECT –sighup_effect=EFFECT
</code></pre><p>先看一下train函数的相关调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">caffe::<span class="function">SignalHandler <span class="title">signal_handler</span><span class="params">(</span></span></span><br><span class="line">      GetRequestedAction(FLAGS_sigint_effect),</span><br><span class="line">      GetRequestedAction(FLAGS_sighup_effect));</span><br><span class="line">solver-&gt;SetActionFunction(signal_handler.GetActionFunction());</span><br></pre></td></tr></table></figure>
<p>函数<code>GetRequesedAction</code>在caffe.cpp中定义，作用是将设置的string类型的标志转变为枚举类型的变量：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">caffe::SolverAction::<span class="function">Enum <span class="title">GetRequestedAction</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; flag_value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (flag_value == <span class="string">"stop"</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> caffe::SolverAction::STOP;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (flag_value == <span class="string">"snapshot"</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> caffe::SolverAction::SNAPSHOT;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (flag_value == <span class="string">"none"</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> caffe::SolverAction::NONE;</span><br><span class="line">  &#125;</span><br><span class="line">  LOG(FATAL) &lt;&lt; <span class="string">"Invalid signal effect \""</span>&lt;&lt; flag_value &lt;&lt; <span class="string">"\" was specified"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// SolverAction::Enum的定义</span></span><br><span class="line"><span class="keyword">namespace</span> SolverAction &#123;</span><br><span class="line">  <span class="keyword">enum</span> Enum &#123;</span><br><span class="line">    NONE = <span class="number">0</span>,  <span class="comment">// Take no special action.</span></span><br><span class="line">    STOP = <span class="number">1</span>,  <span class="comment">// Stop training. snapshot_after_train controls whether a</span></span><br><span class="line">               <span class="comment">// snapshot is created.</span></span><br><span class="line">    SNAPSHOT = <span class="number">2</span>  <span class="comment">// Take a snapshot, and keep training.</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中<code>SolverAction::Enum</code>的定义在solver.hpp中，这是一个定义为枚举类型的数据类型，只有三个可能的值，分别对应了三种处理系统信号的方式：</p>
<ol>
<li>NONE(忽略信号什么都不做)</li>
<li>STOP(停止训练)</li>
<li>SNAPSHOT(保存当前的训练状态，继续训练)</li>
</ol>
<p>再回到train函数中设置如何处理系统信号的代码，其中：<code>FLAGS_sigint_effect</code>和<code>FLAGS_sighup_effect</code>是通过gflags定义和解析的两个Command Line Interface的输入参数，分别对应遇到sigint和sighup信号的处理方式，如果用户不设定，sigint的默认值为<code>stop</code>，sighup的默认值为<code>snapshot</code>。<code>GetRequestedAction</code>函数会将string类型的<code>FLAGS_xx</code>转为<code>SolverAction::Enum</code>类型，并用来定义一个<code>SignalHandler</code>类型的对象<code>signal_handler</code>。可以看到这部分代码都依赖于SignalHandler这个类的接口，看一下相关代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// header file</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SignalHandler</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Contructor. Specify what action to take when a signal is received.</span></span><br><span class="line">  SignalHandler(SolverAction::Enum SIGINT_action,</span><br><span class="line">                SolverAction::Enum SIGHUP_action);</span><br><span class="line">  ~SignalHandler();</span><br><span class="line">  <span class="function">ActionCallback <span class="title">GetActionFunction</span><span class="params">()</span></span>;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  SolverAction::<span class="function">Enum <span class="title">CheckForSignals</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  SolverAction::Enum SIGINT_action_;</span><br><span class="line">  SolverAction::Enum SIGHUP_action_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// source file</span></span><br><span class="line">SignalHandler::SignalHandler(SolverAction::Enum SIGINT_action,</span><br><span class="line">                             SolverAction::Enum SIGHUP_action):</span><br><span class="line">  SIGINT_action_(SIGINT_action),</span><br><span class="line">  SIGHUP_action_(SIGHUP_action) &#123;</span><br><span class="line">  HookupHandler();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HookupHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (already_hooked_up) &#123;</span><br><span class="line">    LOG(FATAL) &lt;&lt; <span class="string">"Tried to hookup signal handlers more than once."</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  already_hooked_up = <span class="literal">true</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line">  sa.sa_handler = &amp;handle_signal;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">sig_atomic_t</span> got_sigint = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">sig_atomic_t</span> got_sighup = <span class="literal">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle_signal</span><span class="params">(<span class="keyword">int</span> signal)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (signal) &#123;</span><br><span class="line">  <span class="keyword">case</span> SIGHUP:</span><br><span class="line">    got_sighup = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> SIGINT:</span><br><span class="line">    got_sigint = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">ActionCallback SignalHandler::GetActionFunction() &#123;</span><br><span class="line">  <span class="keyword">return</span> boost::bind(&amp;SignalHandler::CheckForSignals, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">SolverAction::Enum SignalHandler::CheckForSignals() <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (GotSIGHUP()) &#123;</span><br><span class="line">    <span class="keyword">return</span> SIGHUP_action_;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (GotSIGINT()) &#123;</span><br><span class="line">    <span class="keyword">return</span> SIGINT_action_;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> SolverAction::NONE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GotSIGINT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">bool</span> result = got_sigint;</span><br><span class="line">  got_sigint = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GotSIGHUP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">bool</span> result = got_sighup;</span><br><span class="line">  got_sighup = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ActionCallback的含义</span></span><br><span class="line"><span class="keyword">typedef</span> boost::function&lt;SolverAction::Enum()&gt; ActionCallback;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>SignalHandler这个类有两个数据成员，都是SolverAction::Enum类型的，分别对应sigint和sighup信号，在构造函数中，用解析FLAGS_xx得到的结果分别给两个成员赋值，然后调用了HookupHandler函数，这个函数的主要作用是定义了一个sigaction类型(应该是系统级别的代码)的对象sa，然后通过sa.sa_handler = &amp;handle_signal来设置，当有遇到系统信号时，调用handle_signal函数来处理，而我们可以看到这个函数的处理很简单，就是判断一下当前的信号是什么类型，如果是sigint就将全局的static变量got_sigint变为true，sighup的处理类似。</p>
</blockquote>
<blockquote>
<p>在根据用户设置（或者默认值）的参数定义了signal_handler之后，solver通过SetActionFunction来设置了如何处理系统信号。这个函数的输入为signal_handler的GetActionFunction的返回值，根据上面的代码我们可以看到，GetActionFunction会返回signal_handler这个对象的CheckForSignals函数的地址(boost::bind的具体使用请参考boost官方文档)。而在Solver的SetActionFunction函数中只是简单的把Solver的一个成员action_request_function_赋值为输入参数的值，以当前的例子来说就是，solver对象的action_request_function_指向了signal_handler对象的CheckForSignals函数的地址。其中的ActionCallback是一个函数指针类型，指向了参数为空，返回值为SolverAction::Enum类型的函数(boost::function具体用法参考官方文档)。</p>
</blockquote>
<blockquote>
<p>总结起来，我们通过定义一个SignalHandler类型的对象，告知系统在遇到系统信号的时候回调handle_signal函数来改变全局变量got_sigint和got_sighup的值，然后通过Solver的接口设置了其遇到系统函数将调用signal_handler的Check函数，这个函数实际上就是去判断当前是否遇到了系统信号，如果遇到某个类型的信号，就返回我们之前设置的处理方式(SolverAction::Enum类型)。剩余的具体处理再交给Solver的其它函数，后面会具体分析。</p>
</blockquote>
<h3 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h3><hr>
<p>caffe，虽然内核是C++，但是其封装非常好，对于使用者来说，只需要写一个文本文档，定义网络结构和相关参数，然后就可以直接运行。运行的环境涉及到C++、Python、MATLAB的语言。所以，在不同的编译环境下，把内核的接口进行相应地转换（编译），就可以运行。</p>
<h3 id="Main-Reference"><a href="#Main-Reference" class="headerlink" title="Main Reference"></a>Main Reference</h3><hr>
<p><a href="http://alanse7en.github.io/caffedai-ma-jie-xi-4/" target="_blank" rel="noopener">http://alanse7en.github.io/caffedai-ma-jie-xi-4/</a></p>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div></div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>Donate</span>
  </button>
  <div id="QR" style="display: none;">

    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/img/alipay.jpg" alt="John Sky Alipay"/>
        <p>Alipay</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/06/08/【ML一步一脚印】调试笔记/" rel="next" title="【ML一步一脚印】调试笔记">
                <i class="fa fa-chevron-left"></i> 【ML一步一脚印】调试笔记
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/06/14/【caffe】Brewing ImageNet/" rel="prev" title="【caffe】Brewing ImageNet">
                【caffe】Brewing ImageNet <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      
        <div id="gitment-container"></div>
      
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">John Sky</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">30</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/goldentimecoolk" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:jsktt01@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Sky</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      本站访客数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人次
    </span>
  

  
    <span class="site-pv">
      本站总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  







<!-- LOCAL: You can save these files to your site and update links -->
    
        
        <link rel="stylesheet" href="https://aimingoo.github.io/gitmint/style/default.css">
        <script src="https://aimingoo.github.io/gitmint/dist/gitmint.browser.js"></script>
    
<!-- END LOCAL -->

    

    
      <script type="text/javascript">
      function renderGitment(){
        var gitment = new Gitmint({
            id: decodeURI(window.location.pathname), 
            owner: 'goldentimecoolk',
            repo: 'gitment-comments',
            
            lang: "" || navigator.language || navigator.systemLanguage || navigator.userLanguage,
            
            oauth: {
            
            
                client_secret: 'a221e3a05eedb33f9a4dd3f49da9bc58ff692a70',
            
                client_id: '920e0d6623cd15e1ed42'
            }});
        gitment.render('gitment-container');
      }

      
      renderGitment();
      
      </script>
    







  





  

  

  

  
  

  

  

  

</body>
</html>
